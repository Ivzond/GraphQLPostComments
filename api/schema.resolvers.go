package api

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.47

import (
	"GraphQLPostComments/api/dataloader"
	"GraphQLPostComments/api/generated"
	"GraphQLPostComments/api/model"
	"context"
	"errors"
	"time"

	"github.com/google/uuid"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// CreatePost is the resolver for the createPost field.
func (r *mutationResolver) CreatePost(ctx context.Context, title string, content string, authorID string) (*model.Post, error) {
	post := &model.Post{
		ID:              uuid.New().String(),
		Title:           title,
		Content:         content,
		Author:          &model.User{ID: authorID},
		Comments:        []*model.Comment{},
		CommentsEnabled: true,
		CreatedAt:       time.Now().Format(time.RFC3339),
	}
	return r.Store.CreatePost(post)
}

// Posts is the resolver for the posts field.
func (r *queryResolver) Posts(ctx context.Context) ([]*model.Post, error) {
	return r.Store.GetPosts()
}

// Post is the resolver for the post field.
func (r *queryResolver) Post(ctx context.Context, id string) (*model.Post, error) {
	postLoader := dataloader.NewPostLoader(r.Store)
	commentLoader := dataloader.NewCommentLoader(postLoader, r.Store)

	// Загружаем пост с помощью BatchLoader
	post, err := postLoader.LoadMany(ctx, []string{id})
	if err != nil {
		return nil, err
	}

	if post == nil || len(post) == 0 {
		return nil, errors.New("post not found")
	}

	comments, err := commentLoader.LoadMany(ctx, []string{id})

	post[0].Comments = comments
	return post[0], nil
}

// UpdatePost is the resolver for the updatePost field.
func (r *mutationResolver) UpdatePost(ctx context.Context, id string, title *string, content *string, commentsEnabled *bool) (*model.Post, error) {
	post, err := r.Store.GetPostByID(id)
	if err != nil {
		return nil, err
	}
	if title != nil {
		post.Title = *title
	}
	if content != nil {
		post.Content = *content
	}
	if commentsEnabled != nil {
		post.CommentsEnabled = *commentsEnabled
	}
	return r.Store.UpdatePost(post)
}

// DeletePost is the resolver for the deletePost field.
func (r *mutationResolver) DeletePost(ctx context.Context, id string) (*bool, error) {
	deleted, err := r.Store.DeletePost(id)
	if err != nil {
		return nil, err
	}
	return &deleted, nil
}

// CreateComment is the resolver for the createComment field.
func (r *mutationResolver) CreateComment(ctx context.Context, postID string, content string, authorID string, parentID string) (*model.Comment, error) {
	if len(content) > 2000 {
		return nil, gqlerror.Errorf("The maximum length of a comment is 2000 characters")
	}

	post, err := r.Store.GetPostByID(postID)
	if err != nil {
		return nil, gqlerror.Errorf("Post not found")
	}
	if !post.CommentsEnabled {
		return nil, gqlerror.Errorf("Comments disabled")
	}
	comment := &model.Comment{
		ID:        uuid.New().String(),
		Content:   content,
		Author:    &model.User{ID: authorID},
		Post:      &model.Post{ID: postID},
		Parent:    nil,
		Children:  []*model.Comment{},
		CreatedAt: time.Now().Format(time.RFC3339),
	}
	if parentID != "" {
		comment.Parent = &model.Comment{ID: parentID}
	}
	createdComment, err := r.Store.CreateComment(comment)
	if err != nil {
		return nil, err
	}

	r.mu.Lock()
	defer r.mu.Unlock()
	for _, observer := range r.observers[postID] {
		observer <- createdComment
	}

	return createdComment, nil
}

// Comments is the resolver for the comments field.
func (r *queryResolver) Comments(ctx context.Context, postID string, page *int, limit *int) (*model.CommentPage, error) {
	p := 1
	if page != nil {
		p = *page
	}
	l := 10
	if limit != nil {
		l = *limit
	}
	return r.Store.GetComments(postID, p, l)
}

// DeleteComment is the resolver for the deleteComment field.
func (r *mutationResolver) DeleteComment(ctx context.Context, id string) (*bool, error) {
	deleted, err := r.Store.DeleteComment(id)
	if err != nil {
		return nil, err
	}
	return &deleted, nil
}

// CommentAdded is the resolver for the commentAdded field.
func (r *subscriptionResolver) CommentAdded(ctx context.Context, postID string) (<-chan *model.Comment, error) {
	r.mu.Lock()
	defer r.mu.Unlock()

	if _, ok := r.observers[postID]; !ok {
		r.observers[postID] = map[string]chan *model.Comment{}
	}

	id := uuid.New().String()
	events := make(chan *model.Comment)
	r.observers[postID][id] = events

	go func() {
		<-ctx.Done()
		r.mu.Lock()
		delete(r.observers[postID], id)
		if len(r.observers[postID]) == 0 {
			delete(r.observers, postID)
		}
	}()
	return events, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

// Subscription returns generated.SubscriptionResolver implementation.
func (r *Resolver) Subscription() generated.SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
